/*
 * generated by Xtext 2.9.1
 */
package hu.bme.mit.modes3.test.serializer;

import com.google.inject.Inject;
import hu.bme.mit.modes3.test.services.TestLanguageGrammarAccess;
import hu.bme.mit.modes3.test.testLanguage.CaseDescription;
import hu.bme.mit.modes3.test.testLanguage.CaseName;
import hu.bme.mit.modes3.test.testLanguage.Comment;
import hu.bme.mit.modes3.test.testLanguage.DivergentExpectation;
import hu.bme.mit.modes3.test.testLanguage.DivergentSection;
import hu.bme.mit.modes3.test.testLanguage.Expectations;
import hu.bme.mit.modes3.test.testLanguage.InitialState;
import hu.bme.mit.modes3.test.testLanguage.Model;
import hu.bme.mit.modes3.test.testLanguage.Section;
import hu.bme.mit.modes3.test.testLanguage.Steps;
import hu.bme.mit.modes3.test.testLanguage.StraightExpectation;
import hu.bme.mit.modes3.test.testLanguage.StraightSection;
import hu.bme.mit.modes3.test.testLanguage.TestLanguagePackage;
import hu.bme.mit.modes3.test.testLanguage.TopExpectation;
import hu.bme.mit.modes3.test.testLanguage.TopSection;
import hu.bme.mit.modes3.test.testLanguage.Turnout;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TestLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TestLanguagePackage.CASE_DESCRIPTION:
				sequence_CaseDescription(context, (CaseDescription) semanticObject); 
				return; 
			case TestLanguagePackage.CASE_NAME:
				sequence_CaseName(context, (CaseName) semanticObject); 
				return; 
			case TestLanguagePackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case TestLanguagePackage.DIVERGENT_EXPECTATION:
				sequence_DivergentExpectation(context, (DivergentExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.DIVERGENT_SECTION:
				sequence_DivergentSection(context, (DivergentSection) semanticObject); 
				return; 
			case TestLanguagePackage.EXPECTATIONS:
				sequence_Expectations(context, (Expectations) semanticObject); 
				return; 
			case TestLanguagePackage.INITIAL_STATE:
				sequence_InitialState(context, (InitialState) semanticObject); 
				return; 
			case TestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case TestLanguagePackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case TestLanguagePackage.STEPS:
				sequence_Steps(context, (Steps) semanticObject); 
				return; 
			case TestLanguagePackage.STRAIGHT_EXPECTATION:
				sequence_StraightExpectation(context, (StraightExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.STRAIGHT_SECTION:
				sequence_StraightSection(context, (StraightSection) semanticObject); 
				return; 
			case TestLanguagePackage.TOP_EXPECTATION:
				sequence_TopExpectation(context, (TopExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.TOP_SECTION:
				sequence_TopSection(context, (TopSection) semanticObject); 
				return; 
			case TestLanguagePackage.TURNOUT:
				sequence_Turnout(context, (Turnout) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CaseDescription returns CaseDescription
	 *
	 * Constraint:
	 *     (caseName=CaseName steps=Steps expect=Expectations)
	 */
	protected void sequence_CaseDescription(ISerializationContext context, CaseDescription semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__CASE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__CASE_NAME));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__STEPS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__STEPS));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__EXPECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.CASE_DESCRIPTION__EXPECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseDescriptionAccess().getCaseNameCaseNameParserRuleCall_0_0(), semanticObject.getCaseName());
		feeder.accept(grammarAccess.getCaseDescriptionAccess().getStepsStepsParserRuleCall_1_0(), semanticObject.getSteps());
		feeder.accept(grammarAccess.getCaseDescriptionAccess().getExpectExpectationsParserRuleCall_2_0(), semanticObject.getExpect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseName returns CaseName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CaseName(ISerializationContext context, CaseName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.CASE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.CASE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseNameAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     comment=STRING
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getCommentSTRINGTerminalRuleCall_2_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DivergentExpectation returns DivergentExpectation
	 *
	 * Constraint:
	 *     (divergentExpectedState='ENABLED' | divergentExpectedState='DISABLED')
	 */
	protected void sequence_DivergentExpectation(ISerializationContext context, DivergentExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DivergentSection returns DivergentSection
	 *
	 * Constraint:
	 *     (divergentSectionState='FREE' | divergentSectionState='OCCUPIED')
	 */
	protected void sequence_DivergentSection(ISerializationContext context, DivergentSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expectations returns Expectations
	 *
	 * Constraint:
	 *     (straightExpectation=StraightExpectation divergentExpectation=DivergentExpectation topExpectation=TopExpectation)
	 */
	protected void sequence_Expectations(ISerializationContext context, Expectations semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__STRAIGHT_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__STRAIGHT_EXPECTATION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__DIVERGENT_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__DIVERGENT_EXPECTATION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__TOP_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__TOP_EXPECTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpectationsAccess().getStraightExpectationStraightExpectationParserRuleCall_1_0(), semanticObject.getStraightExpectation());
		feeder.accept(grammarAccess.getExpectationsAccess().getDivergentExpectationDivergentExpectationParserRuleCall_2_0(), semanticObject.getDivergentExpectation());
		feeder.accept(grammarAccess.getExpectationsAccess().getTopExpectationTopExpectationParserRuleCall_3_0(), semanticObject.getTopExpectation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitialState returns InitialState
	 *
	 * Constraint:
	 *     (turnoutID=INT turnout=Turnout?)
	 */
	protected void sequence_InitialState(ISerializationContext context, InitialState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (initialState=InitialState caseDescription+=CaseDescription*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (straightSection=StraightSection DivergentSection=DivergentSection TopSection=TopSection)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__STRAIGHT_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__STRAIGHT_SECTION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__DIVERGENT_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__DIVERGENT_SECTION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__TOP_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__TOP_SECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSectionAccess().getStraightSectionStraightSectionParserRuleCall_0_0(), semanticObject.getStraightSection());
		feeder.accept(grammarAccess.getSectionAccess().getDivergentSectionDivergentSectionParserRuleCall_1_0(), semanticObject.getDivergentSection());
		feeder.accept(grammarAccess.getSectionAccess().getTopSectionTopSectionParserRuleCall_2_0(), semanticObject.getTopSection());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Steps returns Steps
	 *
	 * Constraint:
	 *     (comment=Comment changedTurnout=Turnout? section+=Section+)
	 */
	protected void sequence_Steps(ISerializationContext context, Steps semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StraightExpectation returns StraightExpectation
	 *
	 * Constraint:
	 *     (straightExpectedState='ENABLED' | straightExpectedState='DISABLED')
	 */
	protected void sequence_StraightExpectation(ISerializationContext context, StraightExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StraightSection returns StraightSection
	 *
	 * Constraint:
	 *     (straightSectionState='FREE' | straightSectionState='OCCUPIED')
	 */
	protected void sequence_StraightSection(ISerializationContext context, StraightSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopExpectation returns TopExpectation
	 *
	 * Constraint:
	 *     (topExpectedState='ENABLED' | topExpectedState='DISABLED')
	 */
	protected void sequence_TopExpectation(ISerializationContext context, TopExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopSection returns TopSection
	 *
	 * Constraint:
	 *     (topSectionState='FREE' | topSectionState='OCCUPIED')
	 */
	protected void sequence_TopSection(ISerializationContext context, TopSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Turnout returns Turnout
	 *
	 * Constraint:
	 *     (turnoutState='STRAIGHT' | turnoutState='DIVERGENT')
	 */
	protected void sequence_Turnout(ISerializationContext context, Turnout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
