/*
 * generated by Xtext 2.9.1
 */
package hu.bme.mit.modes3.test.serializer;

import com.google.inject.Inject;
import hu.bme.mit.modes3.test.services.TestLanguageGrammarAccess;
import hu.bme.mit.modes3.test.testLanguage.CaseDescription;
import hu.bme.mit.modes3.test.testLanguage.CaseName;
import hu.bme.mit.modes3.test.testLanguage.Comment;
import hu.bme.mit.modes3.test.testLanguage.Component;
import hu.bme.mit.modes3.test.testLanguage.DivergentExpectation;
import hu.bme.mit.modes3.test.testLanguage.DivergentSection;
import hu.bme.mit.modes3.test.testLanguage.Expectations;
import hu.bme.mit.modes3.test.testLanguage.Model;
import hu.bme.mit.modes3.test.testLanguage.Section;
import hu.bme.mit.modes3.test.testLanguage.StraightExpectation;
import hu.bme.mit.modes3.test.testLanguage.StraightSection;
import hu.bme.mit.modes3.test.testLanguage.TestLanguagePackage;
import hu.bme.mit.modes3.test.testLanguage.TopExpectation;
import hu.bme.mit.modes3.test.testLanguage.TopSection;
import hu.bme.mit.modes3.test.testLanguage.Turnout;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TestLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TestLanguagePackage.CASE_DESCRIPTION:
				sequence_CaseDescription(context, (CaseDescription) semanticObject); 
				return; 
			case TestLanguagePackage.CASE_NAME:
				sequence_CaseName(context, (CaseName) semanticObject); 
				return; 
			case TestLanguagePackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case TestLanguagePackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case TestLanguagePackage.DIVERGENT_EXPECTATION:
				sequence_DivergentExpectation(context, (DivergentExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.DIVERGENT_SECTION:
				sequence_DivergentSection(context, (DivergentSection) semanticObject); 
				return; 
			case TestLanguagePackage.EXPECTATIONS:
				sequence_Expectations(context, (Expectations) semanticObject); 
				return; 
			case TestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case TestLanguagePackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case TestLanguagePackage.STRAIGHT_EXPECTATION:
				sequence_StraightExpectation(context, (StraightExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.STRAIGHT_SECTION:
				sequence_StraightSection(context, (StraightSection) semanticObject); 
				return; 
			case TestLanguagePackage.TOP_EXPECTATION:
				sequence_TopExpectation(context, (TopExpectation) semanticObject); 
				return; 
			case TestLanguagePackage.TOP_SECTION:
				sequence_TopSection(context, (TopSection) semanticObject); 
				return; 
			case TestLanguagePackage.TURNOUT:
				sequence_Turnout(context, (Turnout) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CaseDescription returns CaseDescription
	 *
	 * Constraint:
	 *     (caseName=CaseName comment=Comment? components+=Component+ expect+=Expectations+)
	 */
	protected void sequence_CaseDescription(ISerializationContext context, CaseDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseName returns CaseName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_CaseName(ISerializationContext context, CaseName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.CASE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.CASE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseNameAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     comment=STRING
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getCommentSTRINGTerminalRuleCall_2_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (turnout=Turnout section=Section)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.COMPONENT__TURNOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.COMPONENT__TURNOUT));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.COMPONENT__SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.COMPONENT__SECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAccess().getTurnoutTurnoutParserRuleCall_1_0(), semanticObject.getTurnout());
		feeder.accept(grammarAccess.getComponentAccess().getSectionSectionParserRuleCall_2_0(), semanticObject.getSection());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DivergentExpectation returns DivergentExpectation
	 *
	 * Constraint:
	 *     ((divergentExpectedState='ENABLED' | divergentExpectedState='DISABLED') divID=INT)
	 */
	protected void sequence_DivergentExpectation(ISerializationContext context, DivergentExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DivergentSection returns DivergentSection
	 *
	 * Constraint:
	 *     ((divergentSectionState='FREE' | divergentSectionState='OCCUPIED') divID=INT)
	 */
	protected void sequence_DivergentSection(ISerializationContext context, DivergentSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expectations returns Expectations
	 *
	 * Constraint:
	 *     (expectedTurnoutID=INT straightExpectation=StraightExpectation divergentExpectation=DivergentExpectation topExpectation=TopExpectation)
	 */
	protected void sequence_Expectations(ISerializationContext context, Expectations semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__EXPECTED_TURNOUT_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__EXPECTED_TURNOUT_ID));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__STRAIGHT_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__STRAIGHT_EXPECTATION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__DIVERGENT_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__DIVERGENT_EXPECTATION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__TOP_EXPECTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.EXPECTATIONS__TOP_EXPECTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpectationsAccess().getExpectedTurnoutIDINTTerminalRuleCall_2_0(), semanticObject.getExpectedTurnoutID());
		feeder.accept(grammarAccess.getExpectationsAccess().getStraightExpectationStraightExpectationParserRuleCall_3_0(), semanticObject.getStraightExpectation());
		feeder.accept(grammarAccess.getExpectationsAccess().getDivergentExpectationDivergentExpectationParserRuleCall_4_0(), semanticObject.getDivergentExpectation());
		feeder.accept(grammarAccess.getExpectationsAccess().getTopExpectationTopExpectationParserRuleCall_5_0(), semanticObject.getTopExpectation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     caseDescription+=CaseDescription+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Section returns Section
	 *
	 * Constraint:
	 *     (straightSection=StraightSection divergentSection=DivergentSection topSection=TopSection)
	 */
	protected void sequence_Section(ISerializationContext context, Section semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__STRAIGHT_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__STRAIGHT_SECTION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__DIVERGENT_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__DIVERGENT_SECTION));
			if (transientValues.isValueTransient(semanticObject, TestLanguagePackage.Literals.SECTION__TOP_SECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestLanguagePackage.Literals.SECTION__TOP_SECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSectionAccess().getStraightSectionStraightSectionParserRuleCall_0_0(), semanticObject.getStraightSection());
		feeder.accept(grammarAccess.getSectionAccess().getDivergentSectionDivergentSectionParserRuleCall_1_0(), semanticObject.getDivergentSection());
		feeder.accept(grammarAccess.getSectionAccess().getTopSectionTopSectionParserRuleCall_2_0(), semanticObject.getTopSection());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StraightExpectation returns StraightExpectation
	 *
	 * Constraint:
	 *     ((straightExpectedState='ENABLED' | straightExpectedState='DISABLED') strID=INT)
	 */
	protected void sequence_StraightExpectation(ISerializationContext context, StraightExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StraightSection returns StraightSection
	 *
	 * Constraint:
	 *     ((straightSectionState='FREE' | straightSectionState='OCCUPIED') strID=INT)
	 */
	protected void sequence_StraightSection(ISerializationContext context, StraightSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopExpectation returns TopExpectation
	 *
	 * Constraint:
	 *     ((topExpectedState='ENABLED' | topExpectedState='DISABLED') topID=INT)
	 */
	protected void sequence_TopExpectation(ISerializationContext context, TopExpectation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopSection returns TopSection
	 *
	 * Constraint:
	 *     ((topSectionState='FREE' | topSectionState='OCCUPIED') topID=INT)
	 */
	protected void sequence_TopSection(ISerializationContext context, TopSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Turnout returns Turnout
	 *
	 * Constraint:
	 *     (turnoutID=INT (turnoutState='STRAIGHT' | turnoutState='DIVERGENT'))
	 */
	protected void sequence_Turnout(ISerializationContext context, Turnout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
