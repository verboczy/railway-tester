/*
 * generated by Xtext 2.9.1
 */
package hu.bme.mit.modes3.test.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class TestLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInitialStateAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInitialStateInitialStateParserRuleCall_0_0 = (RuleCall)cInitialStateAssignment_0.eContents().get(0);
		private final Assignment cCaseDescriptionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCaseDescriptionCaseDescriptionParserRuleCall_1_0 = (RuleCall)cCaseDescriptionAssignment_1.eContents().get(0);
		
		//Model:
		//	initialState=InitialState caseDescription+=CaseDescription* // At least one pair of steps and expectations. 
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//initialState=InitialState caseDescription+=CaseDescription*
		public Group getGroup() { return cGroup; }
		
		//initialState=InitialState
		public Assignment getInitialStateAssignment_0() { return cInitialStateAssignment_0; }
		
		//InitialState
		public RuleCall getInitialStateInitialStateParserRuleCall_0_0() { return cInitialStateInitialStateParserRuleCall_0_0; }
		
		//// Specification of the initial state.
		//caseDescription+=CaseDescription*
		public Assignment getCaseDescriptionAssignment_1() { return cCaseDescriptionAssignment_1; }
		
		//CaseDescription
		public RuleCall getCaseDescriptionCaseDescriptionParserRuleCall_1_0() { return cCaseDescriptionCaseDescriptionParserRuleCall_1_0; }
	}
	public class InitialStateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.InitialState");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInitialStateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTurnoutIdKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTurnoutIDAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTurnoutIDINTTerminalRuleCall_3_0 = (RuleCall)cTurnoutIDAssignment_3.eContents().get(0);
		private final Assignment cTurnoutAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTurnoutTurnoutParserRuleCall_4_0 = (RuleCall)cTurnoutAssignment_4.eContents().get(0);
		
		//// The initial state.
		//InitialState:
		//	'[InitialState]'
		//	'turnoutId' '=' turnoutID=INT // The id is given only in the initial state.
		//	turnout=Turnout?;
		@Override public ParserRule getRule() { return rule; }
		
		//'[InitialState]' 'turnoutId' '=' turnoutID=INT // The id is given only in the initial state.
		//turnout=Turnout?
		public Group getGroup() { return cGroup; }
		
		//'[InitialState]'
		public Keyword getInitialStateKeyword_0() { return cInitialStateKeyword_0; }
		
		//'turnoutId'
		public Keyword getTurnoutIdKeyword_1() { return cTurnoutIdKeyword_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//turnoutID=INT
		public Assignment getTurnoutIDAssignment_3() { return cTurnoutIDAssignment_3; }
		
		//INT
		public RuleCall getTurnoutIDINTTerminalRuleCall_3_0() { return cTurnoutIDINTTerminalRuleCall_3_0; }
		
		//// The id is given only in the initial state.
		//turnout=Turnout?
		public Assignment getTurnoutAssignment_4() { return cTurnoutAssignment_4; }
		
		//Turnout
		public RuleCall getTurnoutTurnoutParserRuleCall_4_0() { return cTurnoutTurnoutParserRuleCall_4_0; }
	}
	public class CaseDescriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.CaseDescription");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCaseNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCaseNameCaseNameParserRuleCall_0_0 = (RuleCall)cCaseNameAssignment_0.eContents().get(0);
		private final Assignment cStepsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStepsStepsParserRuleCall_1_0 = (RuleCall)cStepsAssignment_1.eContents().get(0);
		private final Assignment cExpectAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpectExpectationsParserRuleCall_2_0 = (RuleCall)cExpectAssignment_2.eContents().get(0);
		
		//// A pair of steps and expectations.
		//CaseDescription:
		//	caseName=CaseName
		//	steps=Steps
		//	expect=Expectations;
		@Override public ParserRule getRule() { return rule; }
		
		//caseName=CaseName steps=Steps expect=Expectations
		public Group getGroup() { return cGroup; }
		
		//caseName=CaseName
		public Assignment getCaseNameAssignment_0() { return cCaseNameAssignment_0; }
		
		//CaseName
		public RuleCall getCaseNameCaseNameParserRuleCall_0_0() { return cCaseNameCaseNameParserRuleCall_0_0; }
		
		//steps=Steps
		public Assignment getStepsAssignment_1() { return cStepsAssignment_1; }
		
		//Steps
		public RuleCall getStepsStepsParserRuleCall_1_0() { return cStepsStepsParserRuleCall_1_0; }
		
		//expect=Expectations
		public Assignment getExpectAssignment_2() { return cExpectAssignment_2; }
		
		//Expectations
		public RuleCall getExpectExpectationsParserRuleCall_2_0() { return cExpectExpectationsParserRuleCall_2_0; }
	}
	public class CaseNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.CaseName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNameOfTheTestCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//CaseName:
		//	'Name of the test case' ':' name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'Name of the test case' ':' name=ID
		public Group getGroup() { return cGroup; }
		
		//'Name of the test case'
		public Keyword getNameOfTheTestCaseKeyword_0() { return cNameOfTheTestCaseKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}
	public class StepsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Steps");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStepKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentCommentParserRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		private final Assignment cChangedTurnoutAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChangedTurnoutTurnoutParserRuleCall_2_0 = (RuleCall)cChangedTurnoutAssignment_2.eContents().get(0);
		private final Assignment cSectionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSectionSectionParserRuleCall_3_0 = (RuleCall)cSectionAssignment_3.eContents().get(0);
		
		//// May be any change about a turnout (except the id) or a section or a new lock.
		//Steps:
		//	'[Step]'
		//	comment=Comment changedTurnout=Turnout?
		//	section+=Section+;
		@Override public ParserRule getRule() { return rule; }
		
		//'[Step]' comment=Comment changedTurnout=Turnout? section+=Section+
		public Group getGroup() { return cGroup; }
		
		//'[Step]'
		public Keyword getStepKeyword_0() { return cStepKeyword_0; }
		
		//comment=Comment
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//Comment
		public RuleCall getCommentCommentParserRuleCall_1_0() { return cCommentCommentParserRuleCall_1_0; }
		
		//changedTurnout=Turnout?
		public Assignment getChangedTurnoutAssignment_2() { return cChangedTurnoutAssignment_2; }
		
		//Turnout
		public RuleCall getChangedTurnoutTurnoutParserRuleCall_2_0() { return cChangedTurnoutTurnoutParserRuleCall_2_0; }
		
		//section+=Section+
		public Assignment getSectionAssignment_3() { return cSectionAssignment_3; }
		
		//Section
		public RuleCall getSectionSectionParserRuleCall_3_0() { return cSectionSectionParserRuleCall_3_0; }
	}
	public class CommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Comment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cShortDescriptionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCommentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommentSTRINGTerminalRuleCall_2_0 = (RuleCall)cCommentAssignment_2.eContents().get(0);
		
		//Comment:
		//	'Short description' ':' comment=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//'Short description' ':' comment=STRING
		public Group getGroup() { return cGroup; }
		
		//'Short description'
		public Keyword getShortDescriptionKeyword_0() { return cShortDescriptionKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//comment=STRING
		public Assignment getCommentAssignment_2() { return cCommentAssignment_2; }
		
		//STRING
		public RuleCall getCommentSTRINGTerminalRuleCall_2_0() { return cCommentSTRINGTerminalRuleCall_2_0; }
	}
	public class TurnoutElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Turnout");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTurnoutStateIsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTurnoutStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTurnoutStateAlternatives_1_0 = (Alternatives)cTurnoutStateAssignment_1.eContents().get(0);
		private final Keyword cTurnoutStateSTRAIGHTKeyword_1_0_0 = (Keyword)cTurnoutStateAlternatives_1_0.eContents().get(0);
		private final Keyword cTurnoutStateDIVERGENTKeyword_1_0_1 = (Keyword)cTurnoutStateAlternatives_1_0.eContents().get(1);
		
		//// A turnout has a state.
		//Turnout:
		//	'Turnout state is ' turnoutState=('STRAIGHT' | 'DIVERGENT');
		@Override public ParserRule getRule() { return rule; }
		
		//'Turnout state is ' turnoutState=('STRAIGHT' | 'DIVERGENT')
		public Group getGroup() { return cGroup; }
		
		//'Turnout state is '
		public Keyword getTurnoutStateIsKeyword_0() { return cTurnoutStateIsKeyword_0; }
		
		//turnoutState=('STRAIGHT' | 'DIVERGENT')
		public Assignment getTurnoutStateAssignment_1() { return cTurnoutStateAssignment_1; }
		
		//('STRAIGHT' | 'DIVERGENT')
		public Alternatives getTurnoutStateAlternatives_1_0() { return cTurnoutStateAlternatives_1_0; }
		
		//'STRAIGHT'
		public Keyword getTurnoutStateSTRAIGHTKeyword_1_0_0() { return cTurnoutStateSTRAIGHTKeyword_1_0_0; }
		
		//'DIVERGENT'
		public Keyword getTurnoutStateDIVERGENTKeyword_1_0_1() { return cTurnoutStateDIVERGENTKeyword_1_0_1; }
	}
	public class SectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Section");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStraightSectionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStraightSectionStraightSectionParserRuleCall_0_0 = (RuleCall)cStraightSectionAssignment_0.eContents().get(0);
		private final Assignment cDivergentSectionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDivergentSectionDivergentSectionParserRuleCall_1_0 = (RuleCall)cDivergentSectionAssignment_1.eContents().get(0);
		private final Assignment cTopSectionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTopSectionTopSectionParserRuleCall_2_0 = (RuleCall)cTopSectionAssignment_2.eContents().get(0);
		
		//// A section has a position where it connects to the turnout, and a state.
		//Section:
		//	straightSection=StraightSection DivergentSection=DivergentSection TopSection=TopSection;
		@Override public ParserRule getRule() { return rule; }
		
		//straightSection=StraightSection DivergentSection=DivergentSection TopSection=TopSection
		public Group getGroup() { return cGroup; }
		
		//straightSection=StraightSection
		public Assignment getStraightSectionAssignment_0() { return cStraightSectionAssignment_0; }
		
		//StraightSection
		public RuleCall getStraightSectionStraightSectionParserRuleCall_0_0() { return cStraightSectionStraightSectionParserRuleCall_0_0; }
		
		//DivergentSection=DivergentSection
		public Assignment getDivergentSectionAssignment_1() { return cDivergentSectionAssignment_1; }
		
		//DivergentSection
		public RuleCall getDivergentSectionDivergentSectionParserRuleCall_1_0() { return cDivergentSectionDivergentSectionParserRuleCall_1_0; }
		
		//TopSection=TopSection
		public Assignment getTopSectionAssignment_2() { return cTopSectionAssignment_2; }
		
		//TopSection
		public RuleCall getTopSectionTopSectionParserRuleCall_2_0() { return cTopSectionTopSectionParserRuleCall_2_0; }
	}
	public class StraightSectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.StraightSection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromSTRAIGHTIsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStraightSectionStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cStraightSectionStateAlternatives_1_0 = (Alternatives)cStraightSectionStateAssignment_1.eContents().get(0);
		private final Keyword cStraightSectionStateFREEKeyword_1_0_0 = (Keyword)cStraightSectionStateAlternatives_1_0.eContents().get(0);
		private final Keyword cStraightSectionStateOCCUPIEDKeyword_1_0_1 = (Keyword)cStraightSectionStateAlternatives_1_0.eContents().get(1);
		
		//StraightSection:
		//	'Section connecting from STRAIGHT is ' straightSectionState=('FREE' | 'OCCUPIED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from STRAIGHT is ' straightSectionState=('FREE' | 'OCCUPIED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from STRAIGHT is '
		public Keyword getSectionConnectingFromSTRAIGHTIsKeyword_0() { return cSectionConnectingFromSTRAIGHTIsKeyword_0; }
		
		//straightSectionState=('FREE' | 'OCCUPIED')
		public Assignment getStraightSectionStateAssignment_1() { return cStraightSectionStateAssignment_1; }
		
		//('FREE' | 'OCCUPIED')
		public Alternatives getStraightSectionStateAlternatives_1_0() { return cStraightSectionStateAlternatives_1_0; }
		
		//'FREE'
		public Keyword getStraightSectionStateFREEKeyword_1_0_0() { return cStraightSectionStateFREEKeyword_1_0_0; }
		
		//'OCCUPIED'
		public Keyword getStraightSectionStateOCCUPIEDKeyword_1_0_1() { return cStraightSectionStateOCCUPIEDKeyword_1_0_1; }
	}
	public class DivergentSectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.DivergentSection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromDIVERGENTIsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDivergentSectionStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDivergentSectionStateAlternatives_1_0 = (Alternatives)cDivergentSectionStateAssignment_1.eContents().get(0);
		private final Keyword cDivergentSectionStateFREEKeyword_1_0_0 = (Keyword)cDivergentSectionStateAlternatives_1_0.eContents().get(0);
		private final Keyword cDivergentSectionStateOCCUPIEDKeyword_1_0_1 = (Keyword)cDivergentSectionStateAlternatives_1_0.eContents().get(1);
		
		//DivergentSection:
		//	'Section connecting from DIVERGENT is ' divergentSectionState=('FREE' | 'OCCUPIED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from DIVERGENT is ' divergentSectionState=('FREE' | 'OCCUPIED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from DIVERGENT is '
		public Keyword getSectionConnectingFromDIVERGENTIsKeyword_0() { return cSectionConnectingFromDIVERGENTIsKeyword_0; }
		
		//divergentSectionState=('FREE' | 'OCCUPIED')
		public Assignment getDivergentSectionStateAssignment_1() { return cDivergentSectionStateAssignment_1; }
		
		//('FREE' | 'OCCUPIED')
		public Alternatives getDivergentSectionStateAlternatives_1_0() { return cDivergentSectionStateAlternatives_1_0; }
		
		//'FREE'
		public Keyword getDivergentSectionStateFREEKeyword_1_0_0() { return cDivergentSectionStateFREEKeyword_1_0_0; }
		
		//'OCCUPIED'
		public Keyword getDivergentSectionStateOCCUPIEDKeyword_1_0_1() { return cDivergentSectionStateOCCUPIEDKeyword_1_0_1; }
	}
	public class TopSectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.TopSection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromTOPIsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTopSectionStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTopSectionStateAlternatives_1_0 = (Alternatives)cTopSectionStateAssignment_1.eContents().get(0);
		private final Keyword cTopSectionStateFREEKeyword_1_0_0 = (Keyword)cTopSectionStateAlternatives_1_0.eContents().get(0);
		private final Keyword cTopSectionStateOCCUPIEDKeyword_1_0_1 = (Keyword)cTopSectionStateAlternatives_1_0.eContents().get(1);
		
		//TopSection:
		//	'Section connecting from TOP is ' topSectionState=('FREE' | 'OCCUPIED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from TOP is ' topSectionState=('FREE' | 'OCCUPIED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from TOP is '
		public Keyword getSectionConnectingFromTOPIsKeyword_0() { return cSectionConnectingFromTOPIsKeyword_0; }
		
		//topSectionState=('FREE' | 'OCCUPIED')
		public Assignment getTopSectionStateAssignment_1() { return cTopSectionStateAssignment_1; }
		
		//('FREE' | 'OCCUPIED')
		public Alternatives getTopSectionStateAlternatives_1_0() { return cTopSectionStateAlternatives_1_0; }
		
		//'FREE'
		public Keyword getTopSectionStateFREEKeyword_1_0_0() { return cTopSectionStateFREEKeyword_1_0_0; }
		
		//'OCCUPIED'
		public Keyword getTopSectionStateOCCUPIEDKeyword_1_0_1() { return cTopSectionStateOCCUPIEDKeyword_1_0_1; }
	}
	public class ExpectationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.Expectations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExpectedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStraightExpectationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStraightExpectationStraightExpectationParserRuleCall_1_0 = (RuleCall)cStraightExpectationAssignment_1.eContents().get(0);
		private final Assignment cDivergentExpectationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDivergentExpectationDivergentExpectationParserRuleCall_2_0 = (RuleCall)cDivergentExpectationAssignment_2.eContents().get(0);
		private final Assignment cTopExpectationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTopExpectationTopExpectationParserRuleCall_3_0 = (RuleCall)cTopExpectationAssignment_3.eContents().get(0);
		
		//// Shows which sections are expected state of each section
		//Expectations:
		//	'[Expected]'
		//	straightExpectation=StraightExpectation divergentExpectation=DivergentExpectation topExpectation=TopExpectation;
		@Override public ParserRule getRule() { return rule; }
		
		//'[Expected]' straightExpectation=StraightExpectation divergentExpectation=DivergentExpectation
		//topExpectation=TopExpectation
		public Group getGroup() { return cGroup; }
		
		//'[Expected]'
		public Keyword getExpectedKeyword_0() { return cExpectedKeyword_0; }
		
		//straightExpectation=StraightExpectation
		public Assignment getStraightExpectationAssignment_1() { return cStraightExpectationAssignment_1; }
		
		//StraightExpectation
		public RuleCall getStraightExpectationStraightExpectationParserRuleCall_1_0() { return cStraightExpectationStraightExpectationParserRuleCall_1_0; }
		
		//divergentExpectation=DivergentExpectation
		public Assignment getDivergentExpectationAssignment_2() { return cDivergentExpectationAssignment_2; }
		
		//DivergentExpectation
		public RuleCall getDivergentExpectationDivergentExpectationParserRuleCall_2_0() { return cDivergentExpectationDivergentExpectationParserRuleCall_2_0; }
		
		//topExpectation=TopExpectation
		public Assignment getTopExpectationAssignment_3() { return cTopExpectationAssignment_3; }
		
		//TopExpectation
		public RuleCall getTopExpectationTopExpectationParserRuleCall_3_0() { return cTopExpectationTopExpectationParserRuleCall_3_0; }
	}
	public class StraightExpectationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.StraightExpectation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromSTRAIGHTIsExpectedToBeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStraightExpectedStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cStraightExpectedStateAlternatives_1_0 = (Alternatives)cStraightExpectedStateAssignment_1.eContents().get(0);
		private final Keyword cStraightExpectedStateENABLEDKeyword_1_0_0 = (Keyword)cStraightExpectedStateAlternatives_1_0.eContents().get(0);
		private final Keyword cStraightExpectedStateDISABLEDKeyword_1_0_1 = (Keyword)cStraightExpectedStateAlternatives_1_0.eContents().get(1);
		
		//StraightExpectation:
		//	'Section connecting from STRAIGHT is expected to be ' straightExpectedState=('ENABLED' | 'DISABLED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from STRAIGHT is expected to be ' straightExpectedState=('ENABLED' | 'DISABLED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from STRAIGHT is expected to be '
		public Keyword getSectionConnectingFromSTRAIGHTIsExpectedToBeKeyword_0() { return cSectionConnectingFromSTRAIGHTIsExpectedToBeKeyword_0; }
		
		//straightExpectedState=('ENABLED' | 'DISABLED')
		public Assignment getStraightExpectedStateAssignment_1() { return cStraightExpectedStateAssignment_1; }
		
		//('ENABLED' | 'DISABLED')
		public Alternatives getStraightExpectedStateAlternatives_1_0() { return cStraightExpectedStateAlternatives_1_0; }
		
		//'ENABLED'
		public Keyword getStraightExpectedStateENABLEDKeyword_1_0_0() { return cStraightExpectedStateENABLEDKeyword_1_0_0; }
		
		//'DISABLED'
		public Keyword getStraightExpectedStateDISABLEDKeyword_1_0_1() { return cStraightExpectedStateDISABLEDKeyword_1_0_1; }
	}
	public class DivergentExpectationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.DivergentExpectation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromDIVERGENTIsExpectedToBeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDivergentExpectedStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cDivergentExpectedStateAlternatives_1_0 = (Alternatives)cDivergentExpectedStateAssignment_1.eContents().get(0);
		private final Keyword cDivergentExpectedStateENABLEDKeyword_1_0_0 = (Keyword)cDivergentExpectedStateAlternatives_1_0.eContents().get(0);
		private final Keyword cDivergentExpectedStateDISABLEDKeyword_1_0_1 = (Keyword)cDivergentExpectedStateAlternatives_1_0.eContents().get(1);
		
		//DivergentExpectation:
		//	'Section connecting from DIVERGENT is expected to be ' divergentExpectedState=('ENABLED' | 'DISABLED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from DIVERGENT is expected to be ' divergentExpectedState=('ENABLED' | 'DISABLED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from DIVERGENT is expected to be '
		public Keyword getSectionConnectingFromDIVERGENTIsExpectedToBeKeyword_0() { return cSectionConnectingFromDIVERGENTIsExpectedToBeKeyword_0; }
		
		//divergentExpectedState=('ENABLED' | 'DISABLED')
		public Assignment getDivergentExpectedStateAssignment_1() { return cDivergentExpectedStateAssignment_1; }
		
		//('ENABLED' | 'DISABLED')
		public Alternatives getDivergentExpectedStateAlternatives_1_0() { return cDivergentExpectedStateAlternatives_1_0; }
		
		//'ENABLED'
		public Keyword getDivergentExpectedStateENABLEDKeyword_1_0_0() { return cDivergentExpectedStateENABLEDKeyword_1_0_0; }
		
		//'DISABLED'
		public Keyword getDivergentExpectedStateDISABLEDKeyword_1_0_1() { return cDivergentExpectedStateDISABLEDKeyword_1_0_1; }
	}
	public class TopExpectationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "hu.bme.mit.modes3.test.TestLanguage.TopExpectation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSectionConnectingFromTOPIsExpectedToBeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTopExpectedStateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTopExpectedStateAlternatives_1_0 = (Alternatives)cTopExpectedStateAssignment_1.eContents().get(0);
		private final Keyword cTopExpectedStateENABLEDKeyword_1_0_0 = (Keyword)cTopExpectedStateAlternatives_1_0.eContents().get(0);
		private final Keyword cTopExpectedStateDISABLEDKeyword_1_0_1 = (Keyword)cTopExpectedStateAlternatives_1_0.eContents().get(1);
		
		//TopExpectation:
		//	'Section connecting from TOP is expected to be ' topExpectedState=('ENABLED' | 'DISABLED');
		@Override public ParserRule getRule() { return rule; }
		
		//'Section connecting from TOP is expected to be ' topExpectedState=('ENABLED' | 'DISABLED')
		public Group getGroup() { return cGroup; }
		
		//'Section connecting from TOP is expected to be '
		public Keyword getSectionConnectingFromTOPIsExpectedToBeKeyword_0() { return cSectionConnectingFromTOPIsExpectedToBeKeyword_0; }
		
		//topExpectedState=('ENABLED' | 'DISABLED')
		public Assignment getTopExpectedStateAssignment_1() { return cTopExpectedStateAssignment_1; }
		
		//('ENABLED' | 'DISABLED')
		public Alternatives getTopExpectedStateAlternatives_1_0() { return cTopExpectedStateAlternatives_1_0; }
		
		//'ENABLED'
		public Keyword getTopExpectedStateENABLEDKeyword_1_0_0() { return cTopExpectedStateENABLEDKeyword_1_0_0; }
		
		//'DISABLED'
		public Keyword getTopExpectedStateDISABLEDKeyword_1_0_1() { return cTopExpectedStateDISABLEDKeyword_1_0_1; }
	}
	
	
	private final ModelElements pModel;
	private final InitialStateElements pInitialState;
	private final CaseDescriptionElements pCaseDescription;
	private final CaseNameElements pCaseName;
	private final StepsElements pSteps;
	private final CommentElements pComment;
	private final TurnoutElements pTurnout;
	private final SectionElements pSection;
	private final StraightSectionElements pStraightSection;
	private final DivergentSectionElements pDivergentSection;
	private final TopSectionElements pTopSection;
	private final ExpectationsElements pExpectations;
	private final StraightExpectationElements pStraightExpectation;
	private final DivergentExpectationElements pDivergentExpectation;
	private final TopExpectationElements pTopExpectation;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TestLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pInitialState = new InitialStateElements();
		this.pCaseDescription = new CaseDescriptionElements();
		this.pCaseName = new CaseNameElements();
		this.pSteps = new StepsElements();
		this.pComment = new CommentElements();
		this.pTurnout = new TurnoutElements();
		this.pSection = new SectionElements();
		this.pStraightSection = new StraightSectionElements();
		this.pDivergentSection = new DivergentSectionElements();
		this.pTopSection = new TopSectionElements();
		this.pExpectations = new ExpectationsElements();
		this.pStraightExpectation = new StraightExpectationElements();
		this.pDivergentExpectation = new DivergentExpectationElements();
		this.pTopExpectation = new TopExpectationElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("hu.bme.mit.modes3.test.TestLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	initialState=InitialState caseDescription+=CaseDescription* // At least one pair of steps and expectations. 
	//;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//// The initial state.
	//InitialState:
	//	'[InitialState]'
	//	'turnoutId' '=' turnoutID=INT // The id is given only in the initial state.
	//	turnout=Turnout?;
	public InitialStateElements getInitialStateAccess() {
		return pInitialState;
	}
	
	public ParserRule getInitialStateRule() {
		return getInitialStateAccess().getRule();
	}
	
	//// A pair of steps and expectations.
	//CaseDescription:
	//	caseName=CaseName
	//	steps=Steps
	//	expect=Expectations;
	public CaseDescriptionElements getCaseDescriptionAccess() {
		return pCaseDescription;
	}
	
	public ParserRule getCaseDescriptionRule() {
		return getCaseDescriptionAccess().getRule();
	}
	
	//CaseName:
	//	'Name of the test case' ':' name=ID;
	public CaseNameElements getCaseNameAccess() {
		return pCaseName;
	}
	
	public ParserRule getCaseNameRule() {
		return getCaseNameAccess().getRule();
	}
	
	//// May be any change about a turnout (except the id) or a section or a new lock.
	//Steps:
	//	'[Step]'
	//	comment=Comment changedTurnout=Turnout?
	//	section+=Section+;
	public StepsElements getStepsAccess() {
		return pSteps;
	}
	
	public ParserRule getStepsRule() {
		return getStepsAccess().getRule();
	}
	
	//Comment:
	//	'Short description' ':' comment=STRING;
	public CommentElements getCommentAccess() {
		return pComment;
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//// A turnout has a state.
	//Turnout:
	//	'Turnout state is ' turnoutState=('STRAIGHT' | 'DIVERGENT');
	public TurnoutElements getTurnoutAccess() {
		return pTurnout;
	}
	
	public ParserRule getTurnoutRule() {
		return getTurnoutAccess().getRule();
	}
	
	//// A section has a position where it connects to the turnout, and a state.
	//Section:
	//	straightSection=StraightSection DivergentSection=DivergentSection TopSection=TopSection;
	public SectionElements getSectionAccess() {
		return pSection;
	}
	
	public ParserRule getSectionRule() {
		return getSectionAccess().getRule();
	}
	
	//StraightSection:
	//	'Section connecting from STRAIGHT is ' straightSectionState=('FREE' | 'OCCUPIED');
	public StraightSectionElements getStraightSectionAccess() {
		return pStraightSection;
	}
	
	public ParserRule getStraightSectionRule() {
		return getStraightSectionAccess().getRule();
	}
	
	//DivergentSection:
	//	'Section connecting from DIVERGENT is ' divergentSectionState=('FREE' | 'OCCUPIED');
	public DivergentSectionElements getDivergentSectionAccess() {
		return pDivergentSection;
	}
	
	public ParserRule getDivergentSectionRule() {
		return getDivergentSectionAccess().getRule();
	}
	
	//TopSection:
	//	'Section connecting from TOP is ' topSectionState=('FREE' | 'OCCUPIED');
	public TopSectionElements getTopSectionAccess() {
		return pTopSection;
	}
	
	public ParserRule getTopSectionRule() {
		return getTopSectionAccess().getRule();
	}
	
	//// Shows which sections are expected state of each section
	//Expectations:
	//	'[Expected]'
	//	straightExpectation=StraightExpectation divergentExpectation=DivergentExpectation topExpectation=TopExpectation;
	public ExpectationsElements getExpectationsAccess() {
		return pExpectations;
	}
	
	public ParserRule getExpectationsRule() {
		return getExpectationsAccess().getRule();
	}
	
	//StraightExpectation:
	//	'Section connecting from STRAIGHT is expected to be ' straightExpectedState=('ENABLED' | 'DISABLED');
	public StraightExpectationElements getStraightExpectationAccess() {
		return pStraightExpectation;
	}
	
	public ParserRule getStraightExpectationRule() {
		return getStraightExpectationAccess().getRule();
	}
	
	//DivergentExpectation:
	//	'Section connecting from DIVERGENT is expected to be ' divergentExpectedState=('ENABLED' | 'DISABLED');
	public DivergentExpectationElements getDivergentExpectationAccess() {
		return pDivergentExpectation;
	}
	
	public ParserRule getDivergentExpectationRule() {
		return getDivergentExpectationAccess().getRule();
	}
	
	//TopExpectation:
	//	'Section connecting from TOP is expected to be ' topExpectedState=('ENABLED' | 'DISABLED');
	public TopExpectationElements getTopExpectationAccess() {
		return pTopExpectation;
	}
	
	public ParserRule getTopExpectationRule() {
		return getTopExpectationAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
